<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>EventBus 3.0 源码解析 | Bwelco | 封光</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#303F9F">
  
  
  <meta name="keywords" content="">
  <meta name="description" content="引言EventBus是greenrobot发布的一个用于事件订阅和发布的框架,其最大的贡献在于将事件的订阅和发布很好地解耦，使代码更优雅，逻辑更清晰。EventBus的主要特点如下:
组件解耦解耦事件订阅和发布者在Activitives,Fragments和后台线程的使用中表现良好避免了复杂且易导致错误的依赖和生命周期问题简化代码足够快轻量(大约50K)已经在100,000,000+个应用上得到了">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus 3.0 源码解析">
<meta property="og:url" content="http://bwelco.coding.me/2016/12/06/EventBus-3-0-源码解析/index.html">
<meta property="og:site_name" content="Bwelco">
<meta property="og:description" content="引言EventBus是greenrobot发布的一个用于事件订阅和发布的框架,其最大的贡献在于将事件的订阅和发布很好地解耦，使代码更优雅，逻辑更清晰。EventBus的主要特点如下:
组件解耦解耦事件订阅和发布者在Activitives,Fragments和后台线程的使用中表现良好避免了复杂且易导致错误的依赖和生命周期问题简化代码足够快轻量(大约50K)已经在100,000,000+个应用上得到了">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_2.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_3.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_4.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_5.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_6.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_7.png">
<meta property="og:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_8.png">
<meta property="og:updated_time" content="2016-12-06T11:33:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EventBus 3.0 源码解析">
<meta name="twitter:description" content="引言EventBus是greenrobot发布的一个用于事件订阅和发布的框架,其最大的贡献在于将事件的订阅和发布很好地解耦，使代码更优雅，逻辑更清晰。EventBus的主要特点如下:
组件解耦解耦事件订阅和发布者在Activitives,Fragments和后台线程的使用中表现良好避免了复杂且易导致错误的依赖和生命周期问题简化代码足够快轻量(大约50K)已经在100,000,000+个应用上得到了">
<meta name="twitter:image" content="http://o8yrrj7hr.bkt.clouddn.com/eventbus_2.png">
  
  <meta name="summary" content="null">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="http://o8yrrj7hr.bkt.clouddn.com/HexoHead.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">bwelco</h5>
        <a href="mailto:undefined" title="morefreefg@gmail.com" class="mail">morefreefg@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            时光轴
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            标签
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/bwelco" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="http://www.weibo.com/bwelco" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            微博
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-link"></i>
            简历
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p>Bwelco &copy; 2016</p>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">EventBus 3.0 源码解析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">EventBus 3.0 源码解析</h1>
    <h5 class="subtitle">2016-12-06</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <article id="post-EventBus-3-0-源码解析" class="article article-type-post" itemprop="blogPost">
    
      <div class="post-meat flex-row">
        <div class="flex-col"></div>
      </div>
      <div class="post-body">

        <aside class="post-widget" id="post-widget">

          
          <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

          

          
          <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#引言"><span class="post-toc-text">引言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-EventBusAnnotationProcessor-EventBus的正确打开方式"><span class="post-toc-text">1.EventBusAnnotationProcessor:EventBus的正确打开方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-EventBus-3-0-0架构"><span class="post-toc-text">2.EventBus 3.0.0架构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-事件订阅-解除订阅"><span class="post-toc-text">3.事件订阅/解除订阅</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-使用反射获取订阅信息"><span class="post-toc-text">3.1 使用反射获取订阅信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-使用EventBusAnnotationProcessor解析结果获取订阅信息"><span class="post-toc-text">3.2 使用EventBusAnnotationProcessor解析结果获取订阅信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-绑定订阅对象和方法"><span class="post-toc-text">3.3 绑定订阅对象和方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-解除订阅"><span class="post-toc-text">3.4 解除订阅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-事件订阅总结"><span class="post-toc-text">3.5 事件订阅总结</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-事件发布"><span class="post-toc-text">4.事件发布</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-发布普通事件"><span class="post-toc-text">4.1 发布普通事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-2-发布sticky-event"><span class="post-toc-text">4.2 发布sticky event</span></a></li></ol></li></ol></li></ol></li></ol>
          </nav>
          
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>EventBus是greenrobot发布的一个用于事件订阅和发布的框架,其最大的贡献在于将事件的订阅和发布很好地解耦，使代码更优雅，逻辑更清晰。<br>EventBus的主要特点如下:</p>
<p>组件解耦<br>解耦事件订阅和发布者<br>在Activitives,Fragments和后台线程的使用中表现良好<br>避免了复杂且易导致错误的依赖和生命周期问题<br>简化代码<br>足够快<br>轻量(大约50K)<br>已经在100,000,000+个应用上得到了证明<br>具有一些高级特色,如负责传递的线程,订阅优先级,粘性事件等.<br>下面就让我们一起揭开EventBus的神秘面纱。</p>
<h3 id="1-EventBusAnnotationProcessor-EventBus的正确打开方式"><a href="#1-EventBusAnnotationProcessor-EventBus的正确打开方式" class="headerlink" title="1.EventBusAnnotationProcessor:EventBus的正确打开方式"></a>1.EventBusAnnotationProcessor:EventBus的正确打开方式</h3><p>网上有很多介绍EventBus的文章,但是几乎没有提到EventBusAnnotationProcessor的。实际上,从EventBus 3开始引入了注解,它的主要作用在于使用注解而非反射来解析订阅信息,并且这个过程是在编译时而非运行时完成的,因而可使EventBus中的事件订阅节约很多时间。</p>
<p>要使用EventBus 3的这个新特性,需要以下几步:</p>
<p>添加依赖<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'org.greenrobot:eventbus:3.0.0'</span></span><br></pre></td></tr></table></figure></p>
<p>由于注解依赖android-apt-plugin,故需要在项目的gradle的dependencies中引入apt,如下:<br> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classpath</span> <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.8'</span></span><br></pre></td></tr></table></figure></p>
<p>在app module的build.gradle中应用apt插件,并设置apt生成的索引的包名和类名，如果不设置的话在编译时会报错。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apply</span> plugin: <span class="string">'com.neenbedankt.android-apt'</span></span><br><span class="line"></span><br><span class="line">apt &#123;</span><br><span class="line">    <span class="section">arguments</span> &#123;</span><br><span class="line">        <span class="attribute">eventBusIndex</span> <span class="string">"wang.imallen.eventbusannotationsample.MyEventBusIndex"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后,需要在app module的dependencies中引入EventBusAnnotationProcessor:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apt</span> <span class="string">'org.greenrobot:eventbus-annotation-processor:3.0.1'</span></span><br></pre></td></tr></table></figure></p>
<p>完成以上几步后,重新编译一次,即可在app/build/generated/source/apt/debug/下看到生成的MyEventBusIndex类，如下是我的示例中生成的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(ThirdActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onStickyEvent"</span>, wang.imallen.eventbusannotationsample.bean.UserInfo.class,</span><br><span class="line">                    ThreadMode.MAIN, <span class="number">0</span>, <span class="keyword">true</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(MainActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEvent"</span>, wang.imallen.eventbusannotationsample.simple.Event.class,</span><br><span class="line">                    ThreadMode.MAIN),</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventPosting"</span>,</span><br><span class="line">                    wang.imallen.eventbusannotationsample.threadmode.SecondEvent.class),</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventBackground"</span>,</span><br><span class="line">                    wang.imallen.eventbusannotationsample.threadmode.ThirdEvent.class, ThreadMode.BACKGROUND),</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>,</span><br><span class="line">                    wang.imallen.eventbusannotationsample.threadmode.FourthEvent.class, ThreadMode.ASYNC),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是,项目中至少要有一个订阅信息，否则EventBusProcessor获取到的订阅信息为空,自然不生成相应的类了。<br>重新编译之后,在第一次使用EventBus之前(如Application或SplashActivity中),添加如下代码,以使Index生效:</p>
<p> EventBus eventBus=EventBus.builder().addIndex(new MyEventBusIndex()).build();</p>
<p>至于EventBus中常规事件和sticky事件的发布和订阅,都是非常简单的事情,也不是本文的重点,故不再赘述,就有一点需要注意,EventBus 3中sticky events的订阅是在注解中添加类似@Subscriber(sticky=true,threadMode=ThreadMode.MAIN)的属性.<br>读者可以fork我在github中的这个示例进行了解: EventBusProcessor使用示例</p>
<p>需要注意的是,如果不利用EventBusAnnotationProcessor,则EventBus 3的解析速度反而会比之前版本更慢。<br>如下是square发布的EventBus3与之前版本在Nexus One,Nexus 5,Nexus 9上的表现对比:</p>
<p><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_2.png" alt="2"><br><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_3.png" alt="3"><br><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_4.png" alt="4"></p>
<h3 id="2-EventBus-3-0-0架构"><a href="#2-EventBus-3-0-0架构" class="headerlink" title="2.EventBus 3.0.0架构"></a>2.EventBus 3.0.0架构</h3><p>EventBus 3.0.0的发布和订阅事件的架构如下:<br><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_5.png" alt="5"></p>
<p>仍然是在某个线程发布后,通过EventBus分发到不同线程中的Subscriber,这一点与之前版本的并无不同。</p>
<p>EventBus 3.0.0的UML图如下:</p>
<p><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_6.png" alt="6"></p>
<p>需要重点关注的类有EventBus,SubscriberMethodFinder,FindState,SubscriberInfo,PostingThreadState,HandlerPoster,BackgroundPoster,<br>AsyncPoster,PendingPost,Subscription,SubscriberMethod,后面的分析也主要与这些类有关.</p>
<h3 id="3-事件订阅-解除订阅"><a href="#3-事件订阅-解除订阅" class="headerlink" title="3.事件订阅/解除订阅"></a>3.事件订阅/解除订阅</h3><p>下面的代码讲解将结合 EventBusProcessor使用示例 进行。</p>
<p>事件订阅的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//subscriberClass是类似wang.imallen.eventbusannotationsample.MainActivity这样的</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        <span class="comment">//subscriberMethods是类似MainActivity中的onEvent(),onEventAsync(),onEventBackground(),onEventMain(),onEventPosting(),onStickyEvent()这样的</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>subscriberClass就是订阅者所属的Class,如MainActivity.class,之后利用subscriberMethodFinder查找subscriberClass中的订阅方法，其中findSubscriberMethods()方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//ignoreGeneratedIndex默认为false,因为反射成本高</span></span><br><span class="line">       <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">           subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                   + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于反射成本高,而且EventBus 3引入了EventBusAnnotationProcessor,故默认ignoreGeneratedIndex为false,需要注意的是,<br>如果设置ignoreGeneratedIndex为true,则前面使用的MyEventBusIndex无效,还是会走反射解析的分支。</p>
<p>要证实这一点很简单,进入findUsingReflection()方法看一下即可:</p>
<h4 id="3-1-使用反射获取订阅信息"><a href="#3-1-使用反射获取订阅信息" class="headerlink" title="3.1 使用反射获取订阅信息"></a>3.1 使用反射获取订阅信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           findUsingReflectionInSingleClass(findState);</span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>调用的是findUsingReflectionInSingleClass(),其代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">      Method[] methods;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">          <span class="comment">//methods是所有声明的方法，不包括只在基类的方法,如MainActivity中就是onCreate(),onDestroy(),onEvent(),onEventAsync(),onEventBackground(),onEventMain(),onEventPosting(),onStickEvent(),openSecondActivity()</span></span><br><span class="line">          methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">          <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">          methods = findState.clazz.getMethods();</span><br><span class="line">          findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">          <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">          <span class="comment">//必须是public和非static,非abstract,非bridge,非synthetic的方法</span></span><br><span class="line">          <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">              Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">              <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                  Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                  <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//evnetType是类似wang.imallen.eventbusample.simple.Event这样的事件类型</span></span><br><span class="line">                      Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                      <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                          ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                          findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                  subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                  String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                          <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">              String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                      <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码逻辑很简单,就是先获取这个类的declared方法,然后选择其中是public和非static,非abstract,非bridge,非synthetic的方法，如果该方法的注解为Subscribe，则说明它是订阅事件的方法,解析注解参数,最后将解析结果到findState.subscriberMethods中.<br>里面有个小细节就是Class&lt;?&gt;eventType=parameterTypes[0],这意味着即使订阅方法中有多个参数，也只取第一个，如果确认该订阅对象中还未添加该eventtype的方法,则添加到findState.subscriberMethods中，其中checkAdd()方法的代码很简单,不展开分析了。<br>从这里引出一个细节:在一个订阅对象中,同一个事件类型只能有一个回调。</p>
<h4 id="3-2-使用EventBusAnnotationProcessor解析结果获取订阅信息"><a href="#3-2-使用EventBusAnnotationProcessor解析结果获取订阅信息" class="headerlink" title="3.2 使用EventBusAnnotationProcessor解析结果获取订阅信息"></a>3.2 使用EventBusAnnotationProcessor解析结果获取订阅信息</h4><p>回到findSubscriberMethods()这个方法,ignoreGeneratedIndex为false时,通过findUsingInfo()方法来获取订阅信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="comment">//使用while而不是if的原因是findState.moveToSuperclass()会切换findState.clazz对象为基类Class对象,从而循环解析</span></span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">           <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">               <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                       findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果发现获取不到subscriberInfo的话,就还是要使用反射来获取</span></span><br><span class="line">               findUsingReflectionInSingleClass(findState);</span><br><span class="line">           &#125;</span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入getSubscriberInfo()查看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">           <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">               <span class="keyword">return</span> superclassInfo;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">               SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">               <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> info;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里由于subscriberInfo为null,故执行的是第二个分支，即在subscriberInfoIndexes中寻找,那这个subscriberInfoIndexes来自哪里呢？<br>可以看到，它是在constructor中被赋值的,而subscriberMethodFinder就在EventBus的constructor中创建的,这个subscriberInfoIndexes来自builder.subscriberInfoIndexes,而EventBusBuilder中的subscriberInfoIndexes就是来自于第一节中我们提到的如下代码:</p>
<p>EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();</p>
<p>所以,MyEventBusIndex起作用的地方是在SubscriberMethodFinder中,结合MyEventBusIndex的代码可知,EventBusAnnotationProcessor解析出订阅信息，之后以订阅对象的Class为key放入到HashMap中(有的例外的是sticky events,这个在后面会分析),然后在SubscriberMethodFinder的getSubscriberInfo()中,根据findState.clazz来解析已有的结果,如果查找到了则直接返回。</p>
<p>回到findUsingInfo()中,仍然是要检查是否已添加同类型事件的回调,如果没有添加才会添加到findState.subscriberMethods中.</p>
<p>需要注意的是else中findUsingReflectionInSingleClass(findState),我个人认为是冗余代码,除非EventBusAnnotationProcessor解析出错或不完整,某种程度上是对EventBusAnnotationProcessor不自信的表现,期待作者在后面去掉吧。</p>
<p>注意return语句之前的findState.moveToSuperclass()这句，它其实是将findState中的clazz对象换成基类的,也就是说，事件订阅是可以继承的,之后循环之前的过程。</p>
<h4 id="3-3-绑定订阅对象和方法"><a href="#3-3-绑定订阅对象和方法" class="headerlink" title="3.3 绑定订阅对象和方法"></a>3.3 绑定订阅对象和方法</h4><p>回到EventBus#register()中,在获取subscriberMethods之后，就是遍历各订阅方法,逐个绑定。subscribe()的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//eventType是类似wang.imallen.eventbusannotationsample.simpel.Event这样的</span></span><br><span class="line">       Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">       Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">           subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">           subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                       + eventType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">       <span class="comment">//注意这里是i&lt;=size,是为了考虑到subscriptions为空的情况也能添加newSubscription到subscriptions中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">               subscriptions.add(i, newSubscription);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">           subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//subscriber是类似MainActivity,而subscribedEvents是类似MainActivity中涉及到的所有eventType,如Event.class,FirstEvent.class,SecondEvent.class,...,UserInfo.class</span></span><br><span class="line">           typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">       &#125;</span><br><span class="line">       subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">           <span class="comment">//eventInheritance表示是否要考虑继承</span></span><br><span class="line">           <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">               <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">               <span class="comment">// <span class="doctag">Note:</span> Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">               <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">               <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">               <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                   Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                   <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                       Object stickyEvent = entry.getValue();</span><br><span class="line">                       <span class="comment">//给这个新的订阅者发送所有eventType类型或其子类的事件</span></span><br><span class="line">                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果不考虑继承,则只要给新的订阅者发送eventType这个类型的最近一次的粘性事件</span></span><br><span class="line">               Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">               checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法略长,分为以下几步分析:</p>
<p>首先根据subscriber和subscriberMethod生成一个Subscription对象<br>之后从subscriptionsByEventType这个Map中获取对应eventType的所有Subscription对象,如果为空则新建,否则判断是否已经包含newSubscription,如包含则抛出已订阅的异常<br>遍历subscriptions,如果发现subscriberMethod的优先级比某个Subscription对象中的优先级高,则用当前的Subscription对象取代它，之后跳出循环<br>typesBySubscriber是以订阅对象为key,事件类型列表为value的Map,将当前的事件类型添加到对应的List中即可<br>最后一部分比较特殊,如果订阅的是粘性事件,则要分两种情况:<br>如果要考虑事件继承(EventBusBuilder中默认为true)，则需要遍历stickyEvents这个以事件的Class为key,事件本身为value的Map,如果发现某个事件类型是eventType的子类(就是eventType.isAssignableFrom(candidateEventType)的含义),则要发布这个事件类型对应的事件(也就是该事件类型最近一次事件)给这个订阅方法。至于事件发布的代码,在第4节会分析。<br>如果不考虑事件继承,则只需要将eventType最近一次的事件（如果有的话)发送给这个订阅方法即可</p>
<h4 id="3-4-解除订阅"><a href="#3-4-解除订阅" class="headerlink" title="3.4 解除订阅"></a>3.4 解除订阅</h4><p>解除订阅的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">               unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">           typesBySubscriber.remove(subscriber);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单,就是解除与该订阅对象关联的所有事件类型.unsubscribeByEventType()的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">       List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">               Subscription subscription = subscriptions.get(i);</span><br><span class="line">               <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                   subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                   subscriptions.remove(i);</span><br><span class="line">                   i--;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法就是根据事件类型获取所有的订阅信息,如果该订阅信息的订阅对象为当前订阅对象,则将其移除.</p>
<p>解除订阅的逻辑很简单,就不画流程图了.</p>
<h4 id="3-5-事件订阅总结"><a href="#3-5-事件订阅总结" class="headerlink" title="3.5 事件订阅总结"></a>3.5 事件订阅总结</h4><p>至此,事件订阅就基本分析完了,我们可以从中梳理出如下流程:</p>
<p><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_7.png" alt="7"></p>
<p>其中红线标出的是我认为不合理的地方。</p>
<h2 id="4-事件发布"><a href="#4-事件发布" class="headerlink" title="4.事件发布"></a>4.事件发布</h2><h4 id="4-1-发布普通事件"><a href="#4-1-发布普通事件" class="headerlink" title="4.1 发布普通事件"></a>4.1 发布普通事件</h4><p>post()的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">       PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">       List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">       eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">           postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">           postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                   postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">               postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先获取当前线程的PostingThreadState对象，实现方式是ThreadLocal<br>然后将当前event添加到postingState的事件队列中<br>如果当前线程没有正在发布事件,则遍历当前线程的事件队列,将事件逐个发布出去,其中postSingleEvent()的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">       Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">       <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">           List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">           <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">               Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">               subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                   eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">               post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到事件继承的问题(默认情况下eventInheritance为true,即要考虑事件继承),如果考虑事件继承,则要获取这个事件类型的所有基类和实现的接口,并且还要将基类的基类，以及接口的基类也包含进去。如下是lookupAllEventTypes()的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">         List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">         <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">             eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">             <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 eventTypes.add(clazz);</span><br><span class="line">                 addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                 clazz = clazz.getSuperclass();</span><br><span class="line">             &#125;</span><br><span class="line">             eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> eventTypes;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单,就是循环获取基类以及基类的接口,并且将符合条件的事件类型添加到eventTypes中,最后将(eventClass,eventTypes)放入eventTypesCache中。</p>
<p>再回到postSingEvent()中,下面就是遍历eventTypes了,进入postSingleEventForEventType()中,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">      CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">              postingState.event = event;</span><br><span class="line">              postingState.subscription = subscription;</span><br><span class="line">              <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                  aborted = postingState.canceled;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                  postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                  postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果eventClass对应的订阅信息不为空,则将当前事件逐个发布到各订阅对象中,真正的发布处理在postToSubscription()中,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，需要分线程模式为POSTING,MAIN,BACKGROUND,ASYNC这四种情况处理。</p>
<p>如果是POSTING模式,则直接回调事件订阅方法,说明POSTING模式代表发布和订阅回是在同一个线程;<br>如果要在主线程回调,而发布线程就是主线程的话，则直接回调;否则需要利用主线程发布代理(mainThreadPoster)来进行发布;<br>如果要在后台线程中回调,而发布线程是主线程的话,则需要利用后台线程发布代理(backgroundPoster)来进行发布,否则直接发布;<br>如果是异步发布,则不管当前是在什么线程,都是利用异步发布代理(asyncPoster)来进行发布<br>如果threadMode不是其中之一的话，则抛出异常.<br>到这里为止,普通事件的发布就基本梳理完了。</p>
<h4 id="4-2-发布sticky-event"><a href="#4-2-发布sticky-event" class="headerlink" title="4.2 发布sticky event"></a>4.2 发布sticky event</h4><p>粘性事件的发布代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky</span><br><span class="line">   * event of an event's type is kept in memory for future access by subscribers using &#123;<span class="doctag">@link</span> Subscribe#sticky()&#125;.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">          stickyEvents.put(event.getClass(), event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">      post(event);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>非常简单，相比普通事件的发布,就只是多了一步:将当前事件put到当前事件类型对应的实体中。这样做的目的是为了在绑定粘性事件回调时可以将最近一次该事件类型的事件发布给它。</p>
<p>至此,我们可以梳理出发布事件的流程:</p>
<p><img src="http://o8yrrj7hr.bkt.clouddn.com/eventbus_8.png" alt="8"></p>

            <blockquote>
              <p>
                本文地址：
                <a href="http://bwelco.coding.me/2016/12/06/EventBus-3-0-源码解析/" target="_blank" rel="external">http://bwelco.coding.me/2016/12/06/EventBus-3-0-源码解析/</a>
              </p>
              <footer><cite><a href="http://bwelco.coding.me">@Bwelco</a></cite></footer>
            </blockquote>
            </div>
            
<nav class="post-nav">
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/2016/06/19/三星长按Home键搜索/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">三星长按Home键搜索</h4>
      </a>
    </div>
  
</nav>



            




        </div>

      </div>

    

  </article>



    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "EventBus 3.0 源码解析",
    pic: "http://o8yrrj7hr.bkt.clouddn.com/HexoHead.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://bwelco.coding.me/2016/12/06/EventBus-3-0-源码解析/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
